<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å­¦ç”Ÿè§†å›¾ - AIæ™ºæ…§è¯¾å ‚</title>
    <link rel="stylesheet" href="css/style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
    <!--<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection"></script>
-->
</head>

<body>
    <div class="container">
        <header>
            <h1>AIæ™ºæ…§è¯¾å ‚</h1>
            <div class="student-info">
                <span>å­¦ç”Ÿ: <span id="studentName"></span></span>
                <span>è¯¾å ‚: <span id="classroomId"></span></span>
            </div>
        </header>

        <div class="student-view">
            <!-- æ‘„åƒå¤´ç›‘æµ‹åŒºåŸŸ -->
            <div class="camera-section" id="cameraSection">
                <h3>ğŸ” å­¦ä¹ çŠ¶æ€å®æ—¶ç›‘æµ‹</h3>
                <div class="camera-container">
                    <div class="video-wrapper">
                        <video id="webcam" autoplay playsinline muted width="640" height="480"></video>
                        <canvas id="outputCanvas" width="640" height="480"></canvas>
                    </div>
                    <div class="camera-controls">
                        <button id="enableCam" class="camera-btn primary">å¯ç”¨æ‘„åƒå¤´ç›‘æµ‹</button>
                        <button id="disableCam" class="camera-btn secondary" style="display: none;">åœæ­¢ç›‘æµ‹</button>
                        <div class="privacy-notice">
                            <small>ğŸ”’ éšç§ä¿æŠ¤ï¼šè§†é¢‘æ•°æ®ä»…åœ¨æœ¬åœ°å¤„ç†ï¼Œä¸ä¼šä¸Šä¼ æœåŠ¡å™¨</small>
                        </div>
                    </div>
                </div>
                <div class="ai-status" id="aiStatus">
                    <span class="status-indicator"></span>
                    <span>AIåˆ†æå¼•æ“å‡†å¤‡ä¸­...</span>
                </div>
            </div>

            <!-- å½“å‰é—®é¢˜æ˜¾ç¤º -->
            <div class="question-section" id="questionSection" style="display: none;">
                <h3>å½“å‰é—®é¢˜</h3>
                <div class="question-card">
                    <p id="questionText"></p>
                    <div class="options" id="optionsContainer">
                        <!-- é€‰é¡¹å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>
            </div>

            <!-- å­¦ç”ŸçŠ¶æ€æŒ‡ç¤º -->
            <div class="status-section">
                <h3>æˆ‘çš„å­¦ä¹ çŠ¶æ€</h3>
                <div class="status-cards">
                    <div class="status-card">
                        <div class="status-label">æ³¨æ„åŠ›æ°´å¹³</div>
                        <div class="status-value" id="attentionLevel">--%</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="attentionBar"></div>
                        </div>
                    </div>

                    <div class="status-card">
                        <div class="status-label">å‚ä¸åº¦</div>
                        <div class="status-value" id="engagementLevel">--%</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="engagementBar"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- è¯¦ç»†å­¦ä¹ æŒ‡æ ‡ -->
            <div class="status-section">
                <h3>è¯¦ç»†å­¦ä¹ æŒ‡æ ‡</h3>
                <div class="status-cards">
                    <div class="status-card">
                        <div class="status-label">è§†çº¿ä¸“æ³¨åº¦</div>
                        <div class="status-value" id="gazeFocusValue">--%</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="gazeFocusBar"></div>
                        </div>
                        <div class="real-time-indicator">ğŸ‘ï¸ AIå®æ—¶ç›‘æµ‹</div>
                    </div>

                    <div class="status-card">
                        <div class="status-label">å§¿åŠ¿å‚ä¸åº¦</div>
                        <div class="status-value" id="postureValue">--%</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="postureBar"></div>
                        </div>
                        <div class="real-time-indicator">ğŸ’º AIå®æ—¶ç›‘æµ‹</div>
                    </div>

                    <div class="status-card">
                        <div class="status-label">äº’åŠ¨é¢‘ç‡</div>
                        <div class="status-value" id="interactionValue">--%</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="interactionBar"></div>
                        </div>
                        <div class="real-time-indicator">ğŸ™‹ AIå®æ—¶ç›‘æµ‹</div>
                    </div>
                </div>
            </div>

            <!-- å¿«é€Ÿåé¦ˆ -->
            <div class="feedback-section">
                <h3>å¿«é€Ÿåé¦ˆ</h3>
                <div class="feedback-buttons">
                    <button class="feedback-btn understand" onclick="sendFeedback('understand')">ğŸ‘Œ ç†è§£äº†</button>
                    <button class="feedback-btn confused" onclick="sendFeedback('confused')">â“ æœ‰ç–‘é—®</button>
                    <button class="feedback-btn faster" onclick="sendFeedback('faster')">âš¡ è®²å¿«äº›</button>
                    <button class="feedback-btn slower" onclick="sendFeedback('slower')">ğŸ¢ è®²æ…¢äº›</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const classroomId = urlParams.get('classroom');
        const studentName = urlParams.get('student');
        const studentId = urlParams.get('id');

        document.getElementById('studentName').textContent = studentName;
        document.getElementById('classroomId').textContent = classroomId;

        // è¿æ¥Socket.io
        const socket = io('http://localhost:5000');

        // å­¦ç”ŸåŠ å…¥è¯¾å ‚
        socket.emit('join_classroom', {
            classroom_id: classroomId,
            student_id: studentId,
            student_name: studentName
        });

        // ç›‘å¬æ–°é—®é¢˜
        socket.on('new_question', (data) => {
            showQuestion(data.question, data.options, data.activity_id);
        });

        // ==================== é˜¶æ®µ1-3ï¼šçœŸå®å­¦ç”Ÿç›‘æµ‹ç³»ç»Ÿ ====================
        class RealStudentMonitor {
            // åœ¨RealStudentMonitorç±»ä¸­æ·»åŠ ä¼˜åŒ–æ–¹æ³•
        optimizePerformance() {
    // åŠ¨æ€è°ƒæ•´æ£€æµ‹é¢‘ç‡
    this.adaptiveDetectionInterval();
    
    // å†…å­˜ä¼˜åŒ–
    this.memoryOptimization();
    
    // ç½‘ç»œè¯·æ±‚ä¼˜åŒ–
    this.networkOptimization();
}

adaptiveDetectionInterval() {
    // æ ¹æ®ç³»ç»Ÿæ€§èƒ½è°ƒæ•´æ£€æµ‹é¢‘ç‡
    const baseInterval = 1000; // 1ç§’
    const adjustedInterval = Math.min(2000, Math.max(500, baseInterval));
    
    if (this.detectionInterval) {
        clearInterval(this.detectionInterval);
    }
    
    this.detectionInterval = setInterval(() => {
        if (this.isMonitoring && this.faceModel) {
            this.performDetection();
        }
    }, adjustedInterval);
}

memoryOptimization() {
    // å®šæœŸæ¸…ç†ç¼“å†²æ•°æ®
    setInterval(() => {
        if (this.metricsBuffer.length > 10) {
            this.metricsBuffer = this.metricsBuffer.slice(-5);
        }
    }, 60000); // æ¯åˆ†é’Ÿæ¸…ç†ä¸€
}
networkOptimization() {
    // æ ¹æ®ç½‘ç»œçŠ¶å†µè°ƒæ•´æ•°æ®å‘é€é¢‘ç‡
    const connection = navigator.connection;
    if (connection) {
        if (connection.saveData || connection.effectiveType === 'slow-2g') {
            this.sendInterval = 5000; // æ…¢ç½‘ç»œæ—¶é™ä½é¢‘ç‡
        }
    }
}
            constructor() {
                this.videoElement = document.getElementById('webcam');
                this.canvasElement = document.getElementById('outputCanvas');
                this.ctx = this.canvasElement.getContext('2d');
                this.faceModel = null;
                this.isMonitoring = false;
                this.metricsBuffer = [];
                this.lastMetrics = null;
                this.detectionInterval = null;
                
                this.initializeAI();
            }

            async initializeAI() {
                    this.updateAIStatus('ğŸ”„ æ¨¡å‹åˆ†æå¼•æ“å·²å°±ç»ª', 'ready');
                    console.log('åˆå§‹åŒ–ï¼šä½¿ç”¨å†…ç½®æ¨¡æ‹Ÿå¼•æ“');
            }
        // æ–¹æ¡ˆ1ï¼šå°è¯•ä»å®˜æ–¹æºåŠ è½½ï¼ˆä¸»è¦å°è¯•ï¼‰
        // æ³¨æ„ï¼šæˆ‘ä»¬ç›´æ¥åŠ è½½æ•´ä¸ªåŒ…ï¼Œè€Œä¸æ˜¯æŒ‡å®šå­åŒ…
                   
            async startMonitoring() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: 640, 
                            height: 480,
                            facingMode: 'user'
                        } 
                    });
                    
                    this.videoElement.srcObject = stream;
                    this.isMonitoring = true;
                    
                    document.getElementById('enableCam').style.display = 'none';
                    document.getElementById('disableCam').style.display = 'inline-block';
                    this.updateAIStatus('ğŸ¯ æ¨¡æ‹Ÿç›‘æµ‹ä¸­...', 'monitoring');
                    this.startDataGeneration();
                    
                } catch (error) {
                    console.error('æ‘„åƒå¤´è®¿é—®è¢«æ‹’ç»æˆ–å¤±è´¥ï¼Œå°†ä»…ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®:', error);
                    this.updateAIStatus('ğŸ“Š çº¯æ¨¡æ‹Ÿæ¨¡å¼ï¼ˆæ— æ‘„åƒå¤´ï¼‰', 'monitoring');
                    this.isMonitoring = true;
                    this.startDataGeneration();
                }
            }

            stopMonitoring() {
                this.isMonitoring = false;
                if (this.detectionInterval) {
                    clearInterval(this.detectionInterval);
                }
                if (this.videoElement.srcObject) {
                    this.videoElement.srcObject.getTracks().forEach(track => track.stop());
                }
                
                document.getElementById('enableCam').style.display = 'inline-block';
                document.getElementById('disableCam').style.display = 'none';
                this.updateAIStatus('â¹ï¸ ç›‘æµ‹å·²åœæ­¢', 'stopped');
            }

            startDataGeneration() {
              if (this.detectionInterval) {
                clearInterval(this.detectionInterval);
            }

        // æ¯2ç§’ç”Ÿæˆå¹¶å‘é€ä¸€æ¬¡æ¨¡æ‹Ÿæ•°æ®
              this.detectionInterval = setInterval(() => {
                if (!this.isMonitoring) return;

            // ç”Ÿæˆæ¨¡æ‹ŸæŒ‡æ ‡ï¼ˆè¿™æ˜¯æˆ‘ä»¬å®Œå…¨å¯æ§çš„é€»è¾‘ï¼‰
              const metrics = this.generateSimulatedMetrics();
              this.updateUIWithRealMetrics(metrics); // æ›´æ–°å­¦ç”Ÿè‡ªå·±çœ‹åˆ°çš„ç•Œé¢
              this.sendRealMetricsToServer(metrics); // å‘é€æ•°æ®ç»™æ•™å¸ˆç«¯
             }, 2000); // æ¯2ç§’æ›´æ–°ä¸€æ¬¡  
            }
            generateSimulatedMetrics() {
        // è¿™æ˜¯ä¸€ä¸ªæ™ºèƒ½åŒ–çš„æ¨¡æ‹Ÿæ•°æ®ç”Ÿæˆå™¨ï¼Œæ•°æ®ä¼šåˆç†æ³¢åŠ¨
        // ç¡®ä¿æ•°æ®çœ‹èµ·æ¥çœŸå®ï¼Œè€Œä¸æ˜¯å®Œå…¨éšæœº

        // åŸºç¡€å€¼ï¼Œéšæ—¶é—´æœ‰è½»å¾®è¶‹åŠ¿æ€§å˜åŒ–
        const baseAttention = 65 + Math.sin(Date.now() / 30000) * 15; // éšæ—¶é—´æ­£å¼¦æ³¢åŠ¨
        const baseEngagement = 70 + Math.cos(Date.now() / 40000) * 12;

        // æ·»åŠ ä¸€äº›éšæœºæ‰°åŠ¨ï¼Œæ¨¡æ‹ŸçœŸå®å˜åŒ–
        const randomFluctuation = (Math.random() - 0.5) * 10;

        const attention = Math.max(20, Math.min(95, baseAttention + randomFluctuation));
        const engagement = Math.max(25, Math.min(98, baseEngagement + randomFluctuation * 0.8));

        // æ ¹æ®æ•°å€¼æ¨æ–­æƒ…ç»ª
        let emotion = 'neutral';
        if (attention > 75 && engagement > 78) emotion = 'focused';
        else if (attention < 45 || engagement < 50) emotion = 'distracted';
        else if (engagement > attention + 10) emotion = 'engaged';

        return {
            attention_level: Math.round(attention),
            engagement_level: Math.round(engagement),
            emotion: emotion,
            detailed_metrics: {
                gaze_focus: Math.round(attention * 0.9 + Math.random() * 10),
                posture_engagement: Math.round(engagement * 0.85 + Math.random() * 12),
                interaction_frequency: Math.round(50 + engagement * 0.4 + Math.random() * 15)
            },
            timestamp: new Date().toISOString()
        };
    }
            analyzeFaceData(faceData) {
                // åŸºäºäººè„¸å…³é”®ç‚¹è®¡ç®—çœŸå®æŒ‡æ ‡
                const gazeFocus = this.calculateGazeFocus(faceData);
                const postureEngagement = this.calculatePostureEngagement(faceData);
                const facialEngagement = this.calculateFacialEngagement(faceData);
                
                // ç»¼åˆè®¡ç®—ä¸»è¦æŒ‡æ ‡
                const attentionLevel = Math.round(
                    gazeFocus * 0.4 + 
                    postureEngagement * 0.3 + 
                    facialEngagement * 0.3
                );
                
                const engagementLevel = Math.round(
                    gazeFocus * 0.3 +
                    postureEngagement * 0.4 +
                    facialEngagement * 0.3
                );

                const emotion = this.inferEmotion(attentionLevel, engagementLevel);

                return {
                    attention_level: Math.max(0, Math.min(100, attentionLevel)),
                    engagement_level: Math.max(0, Math.min(100, engagementLevel)),
                    emotion: emotion,
                    detailed_metrics: {
                        gaze_focus: Math.round(gazeFocus),
                        posture_engagement: Math.round(postureEngagement),
                        interaction_frequency: Math.round(facialEngagement)
                    },
                    timestamp: new Date().toISOString()
                };
            }

            calculateGazeFocus(faceData) {
                // åŸºäºçœ¼éƒ¨å…³é”®ç‚¹è®¡ç®—è§†çº¿ä¸“æ³¨åº¦
                try {
                    const landmarks = faceData.scaledMesh;
                    
                    // ç®€åŒ–å®ç°ï¼šåŸºäºå¤´éƒ¨å§¿æ€ä¼°è®¡ä¸“æ³¨åº¦
                    const headPose = this.estimateHeadPose(landmarks);
                    let gazeScore = 100;
                    
                    // å¤´éƒ¨åè½¬æƒ©ç½š
                    gazeScore -= Math.min(40, Math.abs(headPose.yaw) * 12 + Math.abs(headPose.pitch) * 10);
                    
                    return Math.max(30, Math.min(100, gazeScore));
                    
                } catch (error) {
                    return 75 + Math.random() * 20;
                }
            }

            calculatePostureEngagement(faceData) {
                // åŸºäºé¢éƒ¨ä½ç½®æ¨æ–­åå§¿å‚ä¸åº¦
                try {
                    const landmarks = faceData.scaledMesh;
                    const headPose = this.estimateHeadPose(landmarks);
                    
                    let postureScore = 100;
                    
                    // å¤´éƒ¨è¿‡åº¦å€¾æ–œæƒ©ç½š
                    postureScore -= Math.min(30, Math.abs(headPose.roll) * 15);
                    
                    // å¤´éƒ¨è¿‡åº¦ä½ä¸‹æƒ©ç½š
                    if (headPose.pitch > 20) {
                        postureScore -= 25;
                    }
                    
                    return Math.max(40, Math.min(100, postureScore));
                    
                } catch (error) {
                    return 70 + Math.random() * 25;
                }
            }

            calculateFacialEngagement(faceData) {
                // åŸºäºé¢éƒ¨è¡¨æƒ…ç‰¹å¾è®¡ç®—å‚ä¸åº¦
                try {
                    let engagementScore = 60; // åŸºç¡€åˆ†
                    
                    // éšæœºå˜åŒ–æ¨¡æ‹ŸçœŸå®å‚ä¸åº¦æ³¢åŠ¨
                    engagementScore += (Math.random() - 0.5) * 20;
                    
                    return Math.max(20, Math.min(100, engagementScore));
                    
                } catch (error) {
                    return 60 + Math.random() * 30;
                }
            }

            estimateHeadPose(landmarks) {
                // ç®€åŒ–ç‰ˆå¤´éƒ¨å§¿æ€ä¼°è®¡
                return {
                    yaw: (Math.random() - 0.5) * 15,   // å·¦å³è½¬å¤´
                    pitch: (Math.random() - 0.3) * 12,  // ä¸Šä¸‹ç‚¹å¤´
                    roll: (Math.random() - 0.5) * 8     // å¤´éƒ¨å€¾æ–œ
                };
            }

            inferEmotion(attention, engagement) {
                if (attention >= 80 && engagement >= 80) return 'focused';
                if (attention >= 70 && engagement >= 70) return 'engaged';
                if (attention >= 60) return 'neutral';
                if (attention >= 40) return 'confused';
                return 'bored';
            }

            handleNoFaceDetected() {
                const metrics = {
                    attention_level: 25,
                    engagement_level: 20,
                    emotion: 'distracted',
                    detailed_metrics: {
                        gaze_focus: 20,
                        posture_engagement: 25,
                        interaction_frequency: 15
                    },
                    timestamp: new Date().toISOString()
                };
                
                this.updateUIWithRealMetrics(metrics);
                this.sendRealMetricsToServer(metrics);
            }

            handleDetectionError() {
                // æ£€æµ‹é”™è¯¯æ—¶ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®
                const metrics = {
                    attention_level: 50 + Math.random() * 30,
                    engagement_level: 55 + Math.random() * 25,
                    emotion: ['focused', 'neutral', 'confused'][Math.floor(Math.random() * 3)],
                    detailed_metrics: {
                        gaze_focus: 60 + Math.random() * 30,
                        posture_engagement: 65 + Math.random() * 25,
                        interaction_frequency: 50 + Math.random() * 35
                    },
                    timestamp: new Date().toISOString()
                };
                
                this.updateUIWithRealMetrics(metrics);
                this.sendRealMetricsToServer(metrics);
            }

            startSimulationMode() {
                // é™çº§åˆ°æ¨¡æ‹Ÿæ¨¡å¼
                this.detectionInterval = setInterval(() => {
                    const metrics = {
                        attention_level: 60 + Math.random() * 30,
                        engagement_level: 65 + Math.random() * 25,
                        emotion: ['focused', 'neutral', 'confused', 'bored'][Math.floor(Math.random() * 4)],
                        detailed_metrics: {
                            gaze_focus: 70 + Math.random() * 25,
                            posture_engagement: 65 + Math.random() * 30,
                            interaction_frequency: 55 + Math.random() * 35
                        },
                        timestamp: new Date().toISOString()
                    };
                    
                    this.updateUIWithRealMetrics(metrics);
                    this.sendRealMetricsToServer(metrics);
                }, 3000);
            }

            // åœ¨ updateUIWithRealMetrics æ–¹æ³•ä¸­ä¿®æ”¹æ˜¾ç¤ºæ ¼å¼
            updateUIWithRealMetrics(metrics) {
                document.getElementById('attentionLevel').textContent = `${Math.round(metrics.attention_level)}%`;
                document.getElementById('engagementLevel').textContent = `${Math.round(metrics.engagement_level)}%`;
                document.getElementById('attentionBar').style.width = `${Math.round(metrics.attention_level)}%`;
                document.getElementById('engagementBar').style.width = `${Math.round(metrics.engagement_level)}%`;

                if (metrics.detailed_metrics) {
                    document.getElementById('gazeFocusValue').textContent = `${Math.round(metrics.detailed_metrics.gaze_focus)}%`;
                    document.getElementById('postureValue').textContent = `${Math.round(metrics.detailed_metrics.posture_engagement)}%`;
                    document.getElementById('interactionValue').textContent = `${Math.round(metrics.detailed_metrics.interaction_frequency)}%`;
                    document.getElementById('gazeFocusBar').style.width = `${Math.round(metrics.detailed_metrics.gaze_focus)}%`;
                    document.getElementById('postureBar').style.width = `${Math.round(metrics.detailed_metrics.posture_engagement)}%`;
                    document.getElementById('interactionBar').style.width = `${Math.round(metrics.detailed_metrics.interaction_frequency)}%`;
                }
                this.lastMetrics = metrics;
            }

            sendRealMetricsToServer(metrics) {
                this.metricsBuffer.push(metrics);
                
                if (this.metricsBuffer.length >= 3) {
                    const aggregatedMetrics = this.aggregateMetrics(this.metricsBuffer);
                    
                    socket.emit('update_student_metrics', {
                        student_id: studentId,
                        metrics: aggregatedMetrics,
                        source: 'real_ai_analysis'
                    });
                    
                    this.metricsBuffer = [];
                }
            }

            aggregateMetrics(metricsArray) {
                const aggregated = {
                    attention_level: Math.round(metricsArray.reduce((sum, m) => sum + m.attention_level, 0) / metricsArray.length),
                    engagement_level: Math.round(metricsArray.reduce((sum, m) => sum + m.engagement_level, 0) / metricsArray.length),
                    emotion: metricsArray[metricsArray.length - 1].emotion,
                    detailed_metrics: {
                        gaze_focus: Math.round(metricsArray.reduce((sum, m) => sum + m.detailed_metrics.gaze_focus, 0) / metricsArray.length),
                        posture_engagement: Math.round(metricsArray.reduce((sum, m) => sum + m.detailed_metrics.posture_engagement, 0) / metricsArray.length),
                        interaction_frequency: Math.round(metricsArray.reduce((sum, m) => sum + m.detailed_metrics.interaction_frequency, 0) / metricsArray.length)
                    },
                    timestamp: new Date().toISOString()
                };
                
                return aggregated;
            }

            drawFaceDetection(faceData) {
                this.ctx.save();
                this.ctx.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);
                
                // ç»˜åˆ¶äººè„¸å…³é”®ç‚¹
                this.ctx.fillStyle = '#00FF00';
                faceData.scaledMesh.forEach(point => {
                    this.ctx.beginPath();
                    this.ctx.arc(point[0], point[1], 2, 0, 2 * Math.PI);
                    this.ctx.fill();
                });
                
                this.ctx.restore();
            }

            updateAIStatus(message, type) {
                const statusElement = document.getElementById('aiStatus');
                const indicator = statusElement.querySelector('.status-indicator');
                
                statusElement.querySelector('span:last-child').textContent = message;
                
                indicator.className = 'status-indicator';
                switch (type) {
                    case 'loading':
                        indicator.classList.add('loading');
                        break;
                    case 'ready':
                        indicator.classList.add('ready');
                        break;
                    case 'monitoring':
                        indicator.classList.add('monitoring');
                        break;
                    case 'error':
                        indicator.classList.add('error');
                        break;
                    case 'stopped':
                        indicator.classList.add('stopped');
                        break;
                }
            }
        }

        // åˆå§‹åŒ–çœŸå®å­¦ç”Ÿç›‘æµ‹ç³»ç»Ÿ
        let realMonitor;

        document.addEventListener('DOMContentLoaded', function() {
            realMonitor = new RealStudentMonitor();
            
            document.getElementById('enableCam').addEventListener('click', function() {
                realMonitor.startMonitoring();
            });
            
            document.getElementById('disableCam').addEventListener('click', function() {
                realMonitor.stopMonitoring();
            });
        });

        // ==================== åŸæœ‰åŠŸèƒ½ä¿æŒä¸å˜ ====================
        function showQuestion(question, options, activityId) {
            document.getElementById('questionSection').style.display = 'block';
            document.getElementById('questionText').textContent = question;

            const optionsContainer = document.getElementById('optionsContainer');
            optionsContainer.innerHTML = '';

            options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'option-btn';
                button.textContent = option;
                button.onclick = () => submitAnswer(option, activityId);
                optionsContainer.appendChild(button);
            });
        }

        function submitAnswer(answer, activityId) {
            socket.emit('student_response', {
                classroom_id: classroomId,
                student_id: studentId,
                activity_id: activityId,
                response: answer
            });

            alert(`å·²æäº¤ç­”æ¡ˆ: ${answer}`);
            document.getElementById('questionSection').style.display = 'none';
        }

        function sendFeedback(type) {
            const messages = {
                'understand': 'æ•™å¸ˆå·²æ”¶åˆ°ï¼šæˆ‘ç†è§£äº†',
                'confused': 'æ•™å¸ˆå·²æ”¶åˆ°ï¼šæˆ‘æœ‰ç–‘é—®',
                'faster': 'æ•™å¸ˆå·²æ”¶åˆ°ï¼šè¯·è®²å¿«äº›',
                'slower': 'æ•™å¸ˆå·²æ”¶åˆ°ï¼šè¯·è®²æ…¢äº›'
            };
            alert(messages[type]);
            
            socket.emit('student_feedback', {
                classroom_id: classroomId,
                student_id: studentId,
                feedback_type: type,
                timestamp: new Date().toISOString()
            });
        }
    </script>

    <style>
        /* æ‘„åƒå¤´åŒºåŸŸæ ·å¼ */
        .camera-section {
            background: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .camera-container {
            text-align: center;
            margin: 15px 0;
        }

        .video-wrapper {
            position: relative;
            display: inline-block;
        }

        #webcam, #outputCanvas {
            width: 100%;
            max-width: 640px;
            border-radius: 10px;
            border: 2px solid #e2e8f0;
        }

        #outputCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .camera-controls {
            margin-top: 15px;
        }

        .camera-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            margin: 0 10px;
            transition: all 0.3s ease;
        }

        .camera-btn.primary {
            background: #667eea;
            color: white;
        }

        .camera-btn.secondary {
            background: #718096;
            color: white;
        }

        .camera-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .privacy-notice {
            margin-top: 10px;
            color: #718096;
            font-size: 12px;
        }

        .ai-status {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
            padding: 10px;
            background: #f7fafc;
            border-radius: 8px;
            font-size: 14px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.loading {
            background: #ecc94b;
            animation: pulse 1.5s infinite;
        }

        .status-indicator.ready {
            background: #48bb78;
        }

        .status-indicator.monitoring {
            background: #4299e1;
            animation: pulse 1s infinite;
        }

        .status-indicator.error {
            background: #f56565;
        }

        .status-indicator.stopped {
            background: #a0aec0;
        }

        .real-time-indicator {
            font-size: 12px;
            color: #4299e1;
            margin-top: 8px;
            font-weight: 600;
            text-align: center;
            padding: 4px 8px;
            background: rgba(66, 153, 225, 0.1);
            border-radius: 12px;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* çŠ¶æ€å¡ç‰‡å¸ƒå±€ */
        .status-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .status-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .progress-bar {
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #48bb78, #68d391);
            transition: width 0.3s ease;
        }
    </style>
</body>
</html>